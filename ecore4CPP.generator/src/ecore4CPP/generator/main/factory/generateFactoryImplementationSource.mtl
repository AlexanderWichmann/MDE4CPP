[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateFactoryImplementationSource('http://www.eclipse.org/emf/2002/Ecore')]

[import ecore4CPP::generator::main::generateType /]
[import ecore4CPP::generator::main::helper /]

[template public generateFactoryImplSource(anEPackage : EPackage) {className : String = anEPackage.name.toUpperFirst().concat('FactoryImpl');}]
[file (anEPackage.name.concat('/impl/').concat(className).concat('.cpp'), false, 'UTF-8')]
#include "[className/].hpp"
#include "[anEPackage.name.toUpperFirst().concat('Package')/].hpp"

[if (not(anEPackage.name = 'ecore'))]
#include "EClass.hpp"
[/if]

[if(anEPackage.name = 'uml')]
#include "impl/ElementImpl.hpp"
[/if]
[comment namespace /]
using namespace [anEPackage.name/];

//*********************************
// Constructor / Destructor
//*********************************

[className/]::[className/]()
{
	[for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name)) ? (aClass.abstract=false)]
	m_idMap.insert(std::pair<std::string,unsigned int>("[aClass.generateTypeClass()/]", EcorePackage::[aClass.name.toUpperCase()/]));
	[/for]
	[comment]	[for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name)) ? (aClass.abstract=false)]
	//m_creatorMap.insert(std::pair<std::string,std::function<ecore::EObject*()>>("[aClass.generateTypeClass()/]",[ '[' /]this[ ']' /](){return this->create[aClass.name/]();}));
	[/for][/comment]
}

[className/]::~[className/]()
{
}

[anEPackage.name.toUpperFirst().concat('Factory')/]* [className/]::create()
{
	return new [className/]();
}

//*********************************
// creators
//*********************************

std::shared_ptr<ecore::EObject> [className/]::create(unsigned int id,  std::shared_ptr<ecore::EObject> container) const
{
	switch(id)
	{
	[for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name)) ? (aClass.abstract=false)]
		[let eRef: EReference = aClass.getFirstContainer()]
	    case EcorePackage::[aClass.name.toUpperCase()/]: return std::shared_ptr<[aClass.name/]>(this->create[aClass.name/](std::dynamic_pointer_cast<[eRef.generateReferenceType(false)/]>(container)));
		[/let]
	[/for]
	default:
	   	    std::cerr << __PRETTY_FUNCTION__ << " ID " << id <<" not found" << std::endl;
	}
	return nullptr;
}

[comment]std::shared_ptr<[needNamespace(anEPackage, 'EObject')/]> [className/]::create([needNamespace(anEPackage, 'EClass*')/] _class) const
{
	if(_class->isAbstract())
    {
    	return nullptr;
   	}

	std::string _className = _class->eClass()->getName();
	return create(_className);
}[/comment]

std::shared_ptr<[needNamespace(anEPackage, 'EObject')/]> [className/]::create([needNamespace(anEPackage, 'EClass*')/] _class, std::shared_ptr<EObject> _container) const
{
	if(_class->isAbstract())
    {
    	return nullptr;
   	}

	std::string _className = _class->eClass()->getName();
	return create(_className, _container);
}

[comment]std::shared_ptr<[needNamespace(anEPackage, 'EObject')/]> [className/]::create(std::string _className) const
{
	auto iter = m_creatorMap.find(_className);
	
	std::shared_ptr<[needNamespace(anEPackage, 'EObject')/]> _createdObject;
	if(iter != m_creatorMap.end())
    {
		//get the ID
        unsigned int id =iter->second;
		return getCreatorFunction(id, owner);
    }

    return nullptr;
}[/comment]

std::shared_ptr<[needNamespace(anEPackage, 'EObject')/]> [className/]::create(std::string _className, std::shared_ptr<EObject> _container) const
{
	auto iter = m_idMap.find(_className);
	
	std::shared_ptr<[needNamespace(anEPackage, 'EObject')/]> _createdObject;
	if(iter != m_idMap.end())
    {
		//get the ID
        unsigned int id =iter->second;
		return create(id, _container);
    }

    return nullptr;
}


[for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name)) ? (aClass.abstract=false)]
[comment][aClass.generateTypeClass()/]* [className/]::create[aClass.name/] () const
{
	return new [aClass.name.toUpperFirst()/]Impl();
}[/comment]

[if (anEPackage.name = 'uml' and (not (aClass.name = 'Object')))]
[aClass.generateTypeClass()/]* [className/]::create[aClass.name/] (std::shared_ptr<uml::Element > owner) const
{
	[aClass.generateTypeClass()/]Impl*  newObj = new [aClass.name.toUpperFirst()/]Impl();
	newObj->m_owner = owner;
	return newObj;
}
[/if]


[let eRef: EReference = aClass.getFirstContainer()]
[aClass.generateTypeClass()/]* [className/]::create[aClass.name/]([eRef.generateReferenceType(true)/] par_[eRef.name/]) const
{
	return new [aClass.name.toUpperFirst()/]Impl(par_[eRef.name/]);
}
[/let]
[/for]

std::shared_ptr<[anEPackage.name.toUpperFirst().concat('Package')/]> [className/]::get[anEPackage.name.toUpperFirst().concat('Package')/]() const
{
	return [anEPackage.name.toUpperFirst().concat('Package')/]::eInstance();
}
[/file]
[/template]