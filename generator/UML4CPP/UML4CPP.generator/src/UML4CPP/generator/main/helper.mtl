[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module helper('http://www.eclipse.org/uml2/5.0.0/UML','http://www.eclipse.org/emf/2002/Ecore')]

[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::helpers::keywords /]
[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::validation::validateModel /]



[**
 * check if application should be created
*/]
[query public prepareApplication(aPackage : Package) : Boolean = eAllContents()->filter(ecore::EAnnotation)->select(source = 'prepareApplication')->notEmpty() /]
[query public hasMainSourceCode(ePackage : Package) : Boolean = if (prepareApplication()) then eAllContents()->filter(ecore::EAnnotation)->select(source = 'prepareApplication')->first().details->select(key = 'sourceCodeMain')->notEmpty() else false endif /]
[query public getMainSourceCode(ePackage : Package) : String = eAllContents()->filter(ecore::EAnnotation)->select(source = 'prepareApplication')->first().details->select(key = 'sourceCodeMain')->first().value /]

[query public hasMainSourceIncludes(ePackage : Package) : Boolean = if (prepareApplication()) then eAllContents()->filter(ecore::EAnnotation)->select(source = 'prepareApplication')->first().details->select(key = 'sourceCodeIncludes')->notEmpty() else false endif /]
[query public getMainSourceIncludes(ePackage : Package) : String = eAllContents()->filter(ecore::EAnnotation)->select(source = 'prepareApplication')->first().details->select(key = 'sourceCodeIncludes')->first().value /]

[**
 * check and get key value from sourcegen eannotation
*/]

[**
 * Generate a qualified name 
 * Chain 
*/]

[query public memberName(anElement : NamedElement) : String = anElement.myQualifiedName().sanitize().substituteAll('.', '_').toLowerFirst()/]
[query public memberNameUpper(anElement : NamedElement) : String = memberName().toUpperCase() /]

[query public classNumberName(aEClass : Class) : String = aEClass.name.toUpperCase() /]

[query public packageGetter(anElement1 : NamedElement, anElement2 : NamedElement) : String = if (anElement1.oclIsUndefined()) then 'nullptr' else anElement1.packageGetterHelper(anElement2) endif /]
[query private packageGetterHelper(anElement1 : NamedElement, anElement2 : NamedElement) : String = if (anElement1.getNearestPackage().oclIsUndefined()) then anElement1.handlePackageGetterError(anElement2.myName()) else needMetaModelPackageGetter(anElement1, anElement2).concat('get_').concat(anElement1.myQualifiedName().substituteAll('::','_').substituteAll('.','_')).concat('()') endif /]


[query public packageGetter(anElement1 : NamedElement) : String = if oclIsUndefined() then 'nullptr' else MetaModelPackageGetter(anElement1).concat('get_').concat(anElement1.myQualifiedName().sanitize()).concat('()') endif /]
[query public MetaModelPackageGetter(anElement1 : Element) : String = anElement1.getNearestPackage().name.concat('::').concat(anElement1.getNearestPackage().name.toUpperFirst()).concat('Package').concat('::eInstance()->') /]

[query public needMetaModelPackageGetter(anElement1 : Element, anElement2 : Element ) : String = if(anElement1.getNearestPackage() = anElement2.getNearestPackage() ) then '' else  anElement1.getNearestPackage().name.concat('::').concat(anElement1.getNearestPackage().name.toUpperFirst()).concat('Package').concat('::eInstance()->')  endif /]

[query public getClassList(aClass : Classifier) : OrderedSet(ecore::EClass) = OrderedSet(ecore::EClass){aClass.eClass().eAllSuperTypes , aClass.eClass()} /]

[query public metamodelClassTypeString(aClass : Classifier,aBaseName : String) : String = if aClass.ancestors()->filter(Package)->first().name = aClass.eClass().ePackage.name then aBaseName else aClass.eClass().ePackage.name.concat('::').concat(aBaseName) endif /]

[query public metamodelClassTypeString(anElement : Element) : String = if anElement.getNearestPackage().name = anElement.eClass().ePackage.name then anElement.eClass().generateTypeClass() else anElement.eClass().ePackage.name.concat('::').concat(anElement.eClass().generateTypeClass()) endif /]

[query public ClassWithNamespace(aClass : Class, base : Class) : String = if aClass.namespace.ns() = base.namespace.ns() or aClass.getNearestPackage().ignoreNamespace() then base.name.toUpperFirst() else base.namespace.ns().concat('::').concat(base.name.toUpperFirst()) endif /]
[query public InterfaceWithNamespace(anInterface : Interface, base : Classifier) : String = if anInterface.namespace.ns() = base.namespace.ns() or anInterface.getNearestPackage().ignoreNamespace() then base.name.toUpperFirst() else base.namespace.ns().concat('::').concat(base.name.toUpperFirst()) endif /]
 
[query public creatorFunction(aType : Type) : String =  metaModelFactory(aType).concat('create').concat(aType.name.toUpperFirst()).concat('()')/]
[query public metaModelFactory(aType : Type) : String = aType.getNearestPackage().name.concat('::').concat(aType.getNearestPackage().name).concat('Factory::eInstance()->')/]

[query public getPackageName(pack : Package) : String = if (pack.name = keyUML()) or (pack.name='Ecore') or (pack.name = 'PrimitiveTypes') then pack.name.toLowerCase().concat('Reflection') else pack.name endif /] 

[query public sanitize(str : String) : String = str.replaceAll(' ', '_').replaceAll('-', '_').replaceAll('::', '_') /] 

[**
 * helper for container based creation
*/]

[** get all associations where aClass is memberType */]
[query public getAssociationsToClass(aClass : Class) : Set(Association) = aClass.getNearestPackage().ownedMember->select(oclIsKindOf(Association))->asOrderedSet() /]
[query public isCompositionForClass(anAssociation : Association, aClass : Class) : Boolean = anAssociation.memberEnd->select(type = aClass and isComposite and (not owner.oclIsKindOf(Association)))->size() > 0/]
[query public getCompositionsToClass(aClass : Class) : Set(Association) = getAssociationsToClass()->select(isCompositionForClass(aClass))->asOrderedSet()->sortedBy(myQualifiedName()) /]



[template public ns(ns : Namespace)]
[if (ns.name = keyUML())]uml[elseif (ns.name='Ecore')]ecore[else][ns.name/][/if]
[/template]

[**
 * Helper for include guard
*/]
[template public startGuard(namedelement : NamedElement)]
[startGuard(namedelement,'')/]
[/template]
[template public startGuard(namedelement : NamedElement, sufix: String)]
//********************************************************************
//*    	
//* Warning: This file was generated by MDE4CPP Generator
//*
//********************************************************************

#ifndef [namedelement.myQualifiedName().sanitize().concat('_').concat(sufix).concat('_hpp').toUpperCase()/]
#define [namedelement.myQualifiedName().sanitize().concat('_').concat(sufix).concat('_hpp').toUpperCase()/]
[/template]

[template public defineDebugMacro(namedelement : NamedElement)]
#ifdef NDEBUG
  #define DEBUG_MESSAGE(a) /**/
#else
  #define DEBUG_MESSAGE(a) a
#endif
[/template]

[template public generateGetter(anElement : NamedElement,impl : Boolean)]
virtual std::shared_ptr<[metamodelClassTypeString(anElement)/]> [anElement.packageGetter(anElement)/][abstractSuffix(impl)/];

[/template]

[template public generateGetterImpl(anElement : NamedElement)]
std::shared_ptr<[metamodelClassTypeString(anElement)/]> [anElement.getNearestPackage().name.toUpperFirst()/]PackageImpl::[anElement.packageGetter(anElement)/]
{
	return [anElement.memberName()/];
}

[/template]

[template public generatePrivatePackageMember(anElement : NamedElement)]
std::shared_ptr<[metamodelClassTypeString(anElement)/]> [anElement.memberName()/] = nullptr;

[/template]

[template public endGuard(namedelement : NamedElement)]
[endGuard(namedelement, '')/]
[/template]

[template public endGuard(namedelement : NamedElement,sufix: String)]
#endif /* end of include guard: [namedelement.myQualifiedName().substituteAll('::','_').concat('_').concat(sufix).concat('_hpp').toUpperCase()/] */
[/template]


[template public generateAbstractDataTypesForwardDeclaration(aClass : Class)]
[if (aClass.ownedAttribute->select(upper <> 1)->size() > 0 or aClass.ownedOperation.ownedParameter->select(upper <> 1)->size() > 0)]
template<class T> class Bag;
[/if]
[/template]

[template public generateAbstractDataTypesForwardDeclaration(anInterface : Interface)]
[if (anInterface.ownedAttribute->select(upper <> 1)->size() > 0 or anInterface.ownedOperation.ownedParameter->select(upper <> 1)->size() > 0)]
template<class T> class Bag;
[/if]
[/template]

[template public generateAbstractDataTypesIncludes(aClass : Class)]
[if (aClass.ownedAttribute->select(upper <> 1)->size() > 0 or aClass.ownedOperation.ownedParameter->select(upper <> 1)->size() > 0)]
#include "abstractDataTypes/Bag.hpp"
[/if]
[/template]

[**
 * Helper for sourcegen annotations
*/]

[query public ignoreNamespace(anElement : Element) : Boolean = anElement.getNearestPackage().valueKey('ignoreNamespace') = '1' /]
[query public isSingleton(anElement : Element) : Boolean = anElement.valueKey('singleton') = '1' /]

[template private handlePackageGetterError(failureElement : NamedElement, name : String)]
nullptr['cannot terminate package of element '.concat(failureElement.toString()).concat(' used by ').concat(name).registerError()/]
[/template]