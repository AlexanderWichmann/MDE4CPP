[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 ****************************************************************************************************************************************************************
 * 
 * module for name check and qualified name generation
 * 
 */]
[module generalHelper('http://www.eclipse.org/uml2/5.0.0/UML','http://www.eclipse.org/emf/2002/Ecore')]

[import UML4CPP::generator::main::helpers::keywords /]
[import UML4CPP::generator::main::helpers::nameHelper /]
[**
 *  query to generate c++ abstract suffix
*/]
[query public abstractSuffix(impl : Boolean) : String = if impl then '' else ' = 0' endif/]

[** 
 * queries to read out annotaion values, default source is the annotation 'codeGen' 
*/]
[query private hasSourceGen(aElement : Element, aSource : String) : Boolean = eAnnotations->select(source = aSource)->notEmpty()/]
[query private getSourceGen(aElement : Element, aSource : String) : EAnnotation = eAnnotations->select(source = aSource)->first()/]
[query private hasKey(aElement : Element, aSource : String, aKey:String) : Boolean = if aElement.hasSourceGen(aSource) then aElement.getSourceGen(aSource).details->select(key = aKey)->notEmpty() else false endif /]
[query public valueKey(aElement : Element, aSource : String, aKey:String) : String = if (hasKey(aSource, aKey)) then aElement.getSourceGen(aSource).details->select(key = aKey)->first().value else '' endif/]
[query public valueKey(aElement : Element, aKey:String) : String = aElement.valueKey(sourceNameCodeGen(), aKey) /]

[**
 * queries to check values of codeGen annotation keys
*/]
[query public ignoreNamespace(anElement : Element) : Boolean = anElement.getNearestPackage().valueKey(sourceNameCodeGen(), keyIgnoreNamespace()) = '1' /] [** check, if namespace should be igored./]
[query public isSingleton(anElement : Element) : Boolean = anElement.valueKey(sourceNameCodeGen(), keySingleton()) = '1' /]	[** check, if a singleton construct should be generated /]

[**
 * queries to check values of prepareApplication annotation keys
*/]
[query public prepareApplication(aPackage : Package) : Boolean = hasSourceGen(sourceNamePrepareApplication()) /]
[query public hasMainSourceCode(ePackage : Package) : Boolean = hasKey(sourceNamePrepareApplication(), keyMainSourceCode()) /]
[query public getMainSourceCode(ePackage : Package) : String = valueKey(sourceNamePrepareApplication(), keyMainSourceCode()) /]
[query public hasMainIncludes(ePackage : Package) : Boolean = hasKey(sourceNamePrepareApplication(), keyMainIncludes()) /]
[query public getMainIncludes(ePackage : Package) : String = valueKey(sourceNamePrepareApplication(), keyMainIncludes()) /]

[**
 * template to generate forward declaration of template class Bag for a Class element
 * forward declaration of 'Bag' is only required, if at least one property or operation parameter has an upper bound > 1 
*/]
[template public generateAbstractDataTypesForwardDeclaration(aClass : Class)]
[if (aClass.ownedAttribute->select(upper <> 1)->size() > 0 or aClass.ownedOperation.ownedParameter->select(upper <> 1)->size() > 0)]
template<class T> class Bag;
[/if]
[/template]

[**
 * template to generate forward declaration of template class Bag for an Interface element
 * forward declaration of 'Bag' is only required, if at least one property or operation parameter has an upper bound > 1
*/]
[template public generateAbstractDataTypesForwardDeclaration(anInterface : Interface)]
[if (anInterface.ownedAttribute->select(upper <> 1)->size() > 0 or anInterface.ownedOperation.ownedParameter->select(upper <> 1)->size() > 0)]
template<class T> class Bag;
[/if]
[/template]

[**
 * template to generate header include of template class Bag for a Class element
 * include of 'Bag' is only required, if at least one property or operation parameter has an upper bound > 1
*/]
[template public generateAbstractDataTypesIncludes(aClass : Class)]
[if (aClass.ownedAttribute->select(upper <> 1)->size() > 0 or aClass.ownedOperation.ownedParameter->select(upper <> 1)->size() > 0)]
#include "abstractDataTypes/Bag.hpp"
[/if]
[/template]

[**
 * template to generate start guard of header declarations, optional with a suffix for guard name
*/]
[template public startGuard(namedelement : NamedElement)]
[startGuard(namedelement,'')/]
[/template]

[template public startGuard(namedelement : NamedElement, sufix: String)]
//********************************************************************
//*    	
//* Warning: This file was generated by MDE4CPP Generator
//*
//********************************************************************

#ifndef [namedelement.myQualifiedName().sanitize().concat('_').concat(sufix).concat('_hpp').toUpperCase()/]
#define [namedelement.myQualifiedName().sanitize().concat('_').concat(sufix).concat('_hpp').toUpperCase()/]
[/template]

[**
 * template to generate end guard of header declarations, optional with a suffix for guard name
*/]
[template public endGuard(namedelement : NamedElement)]
[endGuard(namedelement, '')/]
[/template]

[template public endGuard(namedelement : NamedElement, suffix: String)]
#endif /* end of include guard: [namedelement.myQualifiedName().sanitize().concat('_').concat(suffix).concat('_hpp').toUpperCase()/] */
[/template]

[** 
 * template to generate a macro for enable/ disable printing of messages
*/]
[template public defineDebugMacro(namedelement : NamedElement)]
#ifdef NDEBUG
  #define DEBUG_MESSAGE(a) /**/
#else
  #define DEBUG_MESSAGE(a) a
#endif
[/template]

