[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateExecutionBuildFile('http://www.eclipse.org/uml2/5.0.0/UML')]

[import fUML4CPP::generator::main::generateOpaqueBehaviorExecution /]
[import fUML4CPP::generator::main::parameterHelper /]

[query public metaModelIncludes(aPackage : Package) : Set(Package) = OrderedSet{aPackage.member->filter(Class).attribute.type.getNearestPackage(),aPackage.member->filter(Class).ownedOperation.ownedParameter.type.getNearestPackage(),aPackage.member->filter(Class).attribute.getAppliedStereotypes().getNearestPackage()}->flatten() /]
[query public includeEcorePackages(aPackage : Package) : Boolean = if ((aPackage.name='UML') or (aPackage.name='Ecore')or (aPackage.name='PrimitiveTypes') or (aPackage.eAllContents()->filter(ecore::EAnnotation)->select(source = 'SDK')->notEmpty())) then true else false endif /]
[query public metaModelIncludesWithoutReflection(aPackage : Package) : Set(Package) = aPackage.metaModelIncludes()->reject((name = aPackage.name) or (name = 'PrimitiveTypes') or (name = 'UML')or (name = 'Ecore'))/]
[query public metaModelIncludesReflection(aPackage : Package) : Set(Package) = aPackage.metaModelIncludes()->select((not (name = aPackage.name) or (name = 'PrimitiveTypes') or (name = 'UML')or (name = 'Ecore')))/]
[query public getBinaryTypeName(execMode : Boolean) : String = if (execMode) then 'Executable' else 'SharedLibrary' endif/]
[query public getBinaryTypeExtension(execMode : Boolean) : String = if (execMode) then 'exe' else 'dll' endif/]
[query public getBinaryTypeFolder(execMode : Boolean) : String = if (execMode) then 'exe' else 'libs' endif/]
[query public getBuildTask(execMode : Boolean) : String = if (execMode) then 'NativeExecutableSpec' else 'NativeLibrarySpec' endif/]

[template public generateReflectionLibraryNames(aPackage : Package)]
[if (aPackage.name='UML') or (aPackage.eAllContents()->filter(ecore::EAnnotation)->select(source = 'SDK')->notEmpty())]'ecoreReflection'
[else]'ecoreReflection', 'umlReflection'[/if]
[/template]

[template public generateLibraryNamesWithoutReflection(aPackage : Package)]
[if (aPackage.includeEcorePackages())]'ecore', 'uml', 'fuml'[if (aPackage.name='UML') or (aPackage.eAllContents()->filter(ecore::EAnnotation)->select(source = 'SDK')->notEmpty())], 'primitiveTypesReflection'[/if][else] [for (pack : Package | aPackage.metaModelIncludesWithoutReflection()) separator (', ') after (',')]'[pack.name/]'[/for]'uml', 'ecore', 'fuml', 'primitiveTypesReflection', '[aPackage.name/]'[/if]
[/template]


[template public generateLibraryIncludes(aPackage : Package)]
[if (aPackage.includeEcorePackages())] 
					lib library: "ecore"
					lib library: "uml"
[if (aPackage.name='UML') or (aPackage.eAllContents()->filter(ecore::EAnnotation)->select(source = 'SDK')->notEmpty())]
					lib library: "primitiveTypesReflection"
					lib library: "ecoreReflection"
[/if]
[else]
					lib library: "uml"
					lib library: "ecore"
					lib library: "fuml"
					lib library: "[aPackage.name/]"
					lib library: "primitiveTypesReflection"
					lib library: "ecoreReflection"
					lib library: "umlReflection"
[for (pack : Package | aPackage.metaModelIncludesWithoutReflection()) separator (',')]
					lib library: "[pack.name/]"
[/for]
[/if]
[/template]

[template public generateBuildFile(aPackage : Package)]
[generateBuildFile(aPackage, true)/]
[/template]

[template public generateBuildFile(aPackage : Package, execMode : Boolean) { packageName : String = name.toUpperFirst(); execPackageName : String = packageName.concat('Exec'); }]
[file (aPackage.name.concat('Exec/').concat('build.gradle'), false, 'UTF-8')]
/*-------------------------------------------------
*
* Tasks created by fuml4CPP Generator 
*
*-------------------------------------------------
*/

apply plugin: 'cpp'

description 'C++ project of model [packageName/].uml, generated by Fuml4CPP'

File appendDebugSuffix(File binaryFile) {
  int extensionSeparatorIndex = binaryFile.path.lastIndexOf('.')
  return new File(binaryFile.path.substring(0, extensionSeparatorIndex) + "d" + binaryFile.path.substring(extensionSeparatorIndex))
}
[if (not (execMode))]
task deliver[execPackageName/]Headers(type: Copy) {
	description 'deliver [execPackageName/] header to %MDE4CPP_HOME%/application/include/[execPackageName/]'
	from "."
	into System.getenv('MDE4CPP_HOME')+"/application/include/[execPackageName/]"
	include "**/*.hpp"
	exclude "build", ".gradle"
}[/if]

task deliver[execPackageName/]Debug[getBinaryTypeName(execMode)/](type: Copy) {
	description 'deliver [execPackageName/] debug binary to %MDE4CPP_HOME%/application/bin'
	from "build/[getBinaryTypeFolder(execMode)/]/[execPackageName/]/debug"
	into System.getenv('MDE4CPP_HOME')+"/application/bin"
	include "[execPackageName/]d.[getBinaryTypeExtension(execMode)/]"
}

task deliver[execPackageName/]Release[getBinaryTypeName(execMode)/](type: Copy) {
	description 'deliver [execPackageName/] release binary to %MDE4CPP_HOME%/application/bin/release'
	from "build/[getBinaryTypeFolder(execMode)/]/[execPackageName/]/release"
	into System.getenv('MDE4CPP_HOME')+"/application/bin"
	include "[execPackageName/].[getBinaryTypeExtension(execMode)/]"
}


model {
    toolChains {
    	 gcc(Gcc) {
    	 	"g++"
    	 }
    }
	
    buildTypes {
        debug 
        release
    }
[if (((aPackage.name='UML') or (aPackage.eAllContents()->filter(ecore::EAnnotation)->select(source = 'SDK')->notEmpty())) or not aPackage.includeEcorePackages())]
	repositories {
        libs(PrebuiltLibraries) {
			['['/] [aPackage.generateReflectionLibraryNames()/] [']'/].each {
				delegate."$it" {
					def libraryName = "${name}"
					headers.srcDir System.getenv('MDE4CPP_HOME')+"/application/include"
					binaries.withType(SharedLibraryBinary) {
						if(buildType == buildTypes.debug) {
							sharedLibraryFile = file(System.getenv('MDE4CPP_HOME')+"/application/bin/${libraryName}d.dll")
						} else {
							sharedLibraryFile = file(System.getenv('MDE4CPP_HOME')+"/application/bin/${libraryName}.dll")						
						}
					}
				}	
			}         
		}
	}
[/if]

	repositories {
        libs(PrebuiltLibraries) {
			['['/] [aPackage.generateLibraryNamesWithoutReflection()/] [']'/].each {
				delegate."$it" {
					def libraryName = "${name}"
					headers.srcDir System.getenv('MDE4CPP_HOME')+"/application/include/${libraryName}"
					binaries.withType(SharedLibraryBinary) {
						if(buildType == buildTypes.debug) {
							sharedLibraryFile = file(System.getenv('MDE4CPP_HOME')+"/application/bin/${libraryName}d.dll")
						} else {
							sharedLibraryFile = file(System.getenv('MDE4CPP_HOME')+"/application/bin/${libraryName}.dll")						
						}
					}
				}	
			}         
		}
	}

    components {
        [execPackageName/]([getBuildTask(execMode)/])
        {
        	sources {
                cpp {
                    source {
                        srcDirs "." [if (aPackage.name='uml')], System.getenv('MDE4CPP_HOME')+"/application/include/util"[/if]
[for (aBehavior : OpaqueBehavior | aPackage.getOpaqueBehaviors()->sortedBy(name))]
						include "[aBehavior.name.toUpperFirst()/]Execution.cpp"
[/for]
[for (anAction : CallOperationAction | aPackage.getCallOperationActions()->sortedBy(name))]
						include "[anAction.name.toUpperFirst()/]Execution.cpp"
[/for]
[for (aClassifier : Classifier | getClassiferExecutions()->sortedBy(name))]
						include "[aClassifier.name.toUpperFirst()/]Execution.cpp"
[/for]
[for (act : Activity | aPackage.allOwnedElements()->filter(Class).allOwnedElements()->filter(Operation).method->filter(Activity)->sortedBy(name))]
						include "[act.name.toUpperFirst()/]Execution.cpp"
[/for]
[if (execMode)]
						include "main.cpp"
[/if]
[if (aPackage.name='uml')]
						include "util.cpp"
						include "registry.cpp"
						include "stereotypestorage.cpp"
[/if]
                    }
					exportedHeaders {
                        srcDirs ".", "../", System.getenv('MDE4CPP_HOME')+"/application/include", System.getenv('MDE4CPP_HOME')+"/application/include/Util"
[if (aPackage.name='uml')]
						srcDirs System.getenv('MDE4CPP_HOME')+"/application/include/util"
[/if]
                        include "**/*.hpp"
                    }
[aPackage.generateLibraryIncludes()/]
                }
[if (not (execMode))]
			binaries.withType(StaticLibraryBinarySpec) {
				buildable = false
			}
[/if]
            }
        }
		
		withType(NativeComponentSpec) {
			binaries.withType(NativeBinarySpec) {
				if(buildType == buildTypes.debug) {
[if (execMode)]
					if (it instanceof NativeExecutableBinarySpec) {
						it.getExecutable().setFile(appendDebugSuffix(it.getExecutable().getFile()))							
[else]
					if (it instanceof SharedLibraryBinarySpec) {
						sharedLibraryFile = appendDebugSuffix(sharedLibraryFile)
						sharedLibraryLinkFile = appendDebugSuffix(sharedLibraryLinkFile)
[/if]
					} else if (it instanceof StaticLibraryBinarySpec) {
						staticLibraryFile = appendDebugSuffix(staticLibraryFile)
					} else {
						throw new GradleException("Unknown native library binary")
					}
				}
			}
        }
    }
    
    binaries {
        all {
        	cppCompiler.args '-std=c++11','-Wall', '-Wno-overloaded-virtual', '-pipe'
			if (buildType == buildTypes.debug) {
				cppCompiler.args '-g'
			}
			else {
				cppCompiler.args '-O3', '-DNDEBUG'
			}
        }
    }
}
[if (not (execMode))]tasks.withType(Link[getBinaryTypeName(execMode)/]) { compileTask -> deliver[execPackageName/]Headers.mustRunAfter compileTask }[/if]
tasks.withType(Link[getBinaryTypeName(execMode)/]) { compileTask -> deliver[execPackageName/]Debug[getBinaryTypeName(execMode)/].mustRunAfter compileTask }
tasks.withType(Link[getBinaryTypeName(execMode)/]) { compileTask -> deliver[execPackageName/]Release[getBinaryTypeName(execMode)/].mustRunAfter compileTask }

task compile[execPackageName/](dependsOn: ['['/]'build', 'deliver[execPackageName/]Headers'[if (not (execMode))], 'deliver[execPackageName/]Debug[getBinaryTypeName(execMode)/]'[/if], 'deliver[execPackageName/]Release[getBinaryTypeName(execMode)/]'[']'/]){
	group '[packageName/]'
	description 'compile [execPackageName/] in debug and release'
}
task compile[execPackageName/]Debug(dependsOn: ['['/]'[execPackageName/]Debug[getBinaryTypeName(execMode)/]'[if (not (execMode))], 'deliver[execPackageName/]Headers'[/if], 'deliver[execPackageName/]Debug[getBinaryTypeName(execMode)/]'[']'/]) {
	group '[packageName/]'
	description 'compile [execPackageName/] in debug'
}
task compile[execPackageName/]Release(dependsOn: ['['/]'[execPackageName/]Release[getBinaryTypeName(execMode)/]'[if (not (execMode))], 'deliver[execPackageName/]Headers'[/if], 'deliver[execPackageName/]Release[getBinaryTypeName(execMode)/]'[']'/]) {
	group '[packageName/]'
	description 'compile [execPackageName/] in release'
}
[/file]

[file ('build.gradle', false, 'UTF-8')]
/*-------------------------------------------------
*
* Tasks created by fUML4CPP Generator 
*
*-------------------------------------------------
*/

description 'C++ projects of model [packageName/] generated by fUML4CPP'

task compile[packageName/]All(dependsOn: [ '[' /]'[packageName/]:compile[packageName/]', '[execPackageName/]:compile[execPackageName/]'[ ']' /]) {
	group '[packageName/]'
	description 'compile the binaries for the fuml generated model [packageName/] in release and debug'
}
tasks.getByPath('[execPackageName/]:compile[execPackageName/]').mustRunAfter tasks.getByPath('[packageName/]:compile[packageName/]')

task compile[packageName/]AllDebug(dependsOn: [ '[' /]'[packageName/]:compile[packageName/]Debug', '[execPackageName/]:compile[execPackageName/]Debug'[ ']' /]) {
	group '[packageName/]'
	description 'compile the binaries for the fuml generated model [packageName/] in release and debug'
}
tasks.getByPath('[execPackageName/]:compile[execPackageName/]Debug').mustRunAfter tasks.getByPath('[packageName/]:compile[packageName/]Debug')

task compile[packageName/]AllRelease(dependsOn: [ '[' /]'[packageName/]:compile[packageName/]Release', '[execPackageName/]:compile[execPackageName/]Release'[ ']' /]) {
	group '[packageName/]'
	description 'compile the binaries for the fuml generated model [packageName/] in release and debug'
}
tasks.getByPath('[execPackageName/]:compile[execPackageName/]Release').mustRunAfter tasks.getByPath('[packageName/]:compile[packageName/]Release')
[/file]

[file ('../build.gradle', false, 'UTF-8')]
description 'Build tasks for project: [packageName/]'

task build[packageName/](dependsOn: ['['/]'model:generate[packageName/]', 'src_gen:compile[packageName/]All'[']'/]) {
	group '[packageName/]'
	description 'build [packageName/] in debug and release'
}
task build[packageName/]Debug(dependsOn: ['['/]'model:generate[packageName/]', 'src_gen:compile[packageName/]AllDebug'[']'/]) {
	group '[packageName/]'
	description 'build [packageName/] in debug'
}
task build[packageName/]Release(dependsOn: ['['/]'model:generate[packageName/]', 'src_gen:compile[packageName/]AllRelease'[']'/]) {
	group '[packageName/]'
	description 'build [packageName/] in release'
}

tasks.getByPath('src_gen:compile[packageName/]All').mustRunAfter tasks.getByPath('model:generate[packageName/]')
tasks.getByPath('src_gen:compile[packageName/]AllDebug').mustRunAfter tasks.getByPath('model:generate[packageName/]')
tasks.getByPath('src_gen:compile[packageName/]AllRelease').mustRunAfter tasks.getByPath('model:generate[packageName/]')
[/file]


[file ('settings.gradle', false, 'UTF-8')]
include '[packageName/]', '[execPackageName/]'
[/file]

[file ('../settings.gradle', false, 'UTF-8')]
include 'model', 'src_gen', 'src_gen:[packageName/]', 'src_gen:[execPackageName/]'
[/file]
[/template]