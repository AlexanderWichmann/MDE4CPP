[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateExecutionBuildFile('http://www.eclipse.org/uml2/5.0.0/UML')]

[import fUML4CPP::generator::main::generateOpaqueBehaviorExecution /]
[import fUML4CPP::generator::main::parameterHelper /]
[import UML4CPP::generator::main::helper /]

[query public metaModelIncludes(aPackage : Package) : Set(Package) = OrderedSet{aPackage.member->filter(Class).attribute.type.getNearestPackage(),aPackage.member->filter(Class).ownedOperation.ownedParameter.type.getNearestPackage(),aPackage.member->filter(Class).attribute.getAppliedStereotypes().getNearestPackage(), aPackage.member->filter(Class).interfaceRealization.supplier.getNearestPackage(), aPackage.getCallOperationActions().operation.method->reject(oclIsUndefined()).ownedParameter.type.getNearestPackage()}->flatten() /]
[query public includeEcorePackages(aPackage : Package) : Boolean = if ((aPackage.name='UML') or (aPackage.name='Ecore')or (aPackage.name='PrimitiveTypes') or (aPackage.eAllContents()->filter(ecore::EAnnotation)->select(source = 'SDK')->notEmpty())) then true else false endif /]
[query public metaModelIncludesWithoutReflection(aPackage : Package) : Set(Package) = aPackage.metaModelIncludes()->reject((name = aPackage.name) or (name = 'PrimitiveTypes') or (name = 'UML')or (name = 'Ecore'))/]
[query public metaModelIncludesReflection(aPackage : Package) : Set(Package) = aPackage.metaModelIncludes()->select((not (name = aPackage.name) or (name = 'PrimitiveTypes') or (name = 'UML')or (name = 'Ecore')))/]
[query public metaModelLibrariesNamesForNonReflectionModels(aPackage : Package) : Set(String) = if(metaModelIncludesWithoutReflection()->size() = 0) then OrderedSet{'ecore', 'uml', 'fuml', 'ecoreReflection', 'primitiveTypesReflection', 'umlReflection', aPackage.name} else OrderedSet{'ecore', 'uml', 'fuml', 'ecoreReflection', 'primitiveTypesReflection', 'umlReflection', aPackage.name}->addAll(metaModelIncludesWithoutReflection()->sortedBy(name).name)->flatten() endif/]
[query public metaModelLibrariesNamesForReflectionModels(aPackage : Package) : Set(String) = if ((aPackage.name='UML') or (aPackage.eAllContents()->filter(ecore::EAnnotation)->select(source = 'SDK')->notEmpty())) then OrderedSet{'ecore', 'uml', 'ecoreReflection', 'primitiveTypesReflection'} else OrderedSet{'ecore', 'uml'} endif/]
[query public metaModelLibrariesNames(aPackage : Package) : Set(String) = if (aPackage.includeEcorePackages()) then metaModelLibrariesNamesForReflectionModels() else metaModelLibrariesNamesForNonReflectionModels() endif/]
[query public getBinaryTypeName(buildLibrary : Boolean) : String = if (buildLibrary) then 'SharedLibrary' else 'Executable' endif/]
[query public getBinaryTypeExtension(buildLibrary : Boolean) : String = if (buildLibrary) then 'dll' else 'exe' endif/]
[query public getBinaryTypeFolder(buildLibrary : Boolean) : String = if (buildLibrary) then 'libs' else 'exe' endif/]
[query public getBuildTask(buildLibrary : Boolean) : String = if (buildLibrary) then 'NativeLibrarySpec' else 'NativeExecutableSpec' endif/]

[template public generateExecutionBuildFile(aPackage : Package)]
[generateExecutionBuildFile(aPackage, false)/]
[/template]

[template public generateExecutionBuildFile(aPackage : Package, buildLibrary : Boolean) { packageName : String = name.toUpperFirst(); execPackageName : String = packageName.concat('Exec'); }]
[file (aPackage.name.concat('Exec/').concat('CMakeLists.txt'), false, 'UTF-8')]
#############################################################################
#																			#
#		 			CMakeList created by fUML4CPP Generator					# 
#																			#
#############################################################################

# C++ project of model [packageName/].ecore, generated by fUML4CPP

CMAKE_MINIMUM_REQUIRED(VERSION 3.9)

SET(CMAKE_C_COMPILER "gcc.exe")
SET(CMAKE_CXX_COMPILER "g++.exe")

PROJECT([execPackageName/])

IF(NOT CMAKE_BUILD_TYPE) 
    SET(CMAKE_BUILD_TYPE Debug)
ENDIF(NOT CMAKE_BUILD_TYPE)
SET(CMAKE_DEBUG_POSTFIX d)

SET(CMAKE_CXX_STANDARD 14)
SET(GCC_COVERAGE_LINK_FLAGS "-fopenmp")
SET(CMAKE_CXX_FLAGS "-Wall -Wno-overloaded-virtual -Wdeprecated-declarations -fopenmp -fmax-errors=5")
SET(CMAKE_CXX_FLAGS_DEBUG " -Og -ggdb")
SET(CMAKE_CXX_FLAGS_RELEASE " -O3 -DNDEBUG")

string(REPLACE "\\" "/" MDE4CPP_HOME $ENV{MDE4CPP_HOME})

SET(SOURCE_FILES
[for (aBehavior : OpaqueBehavior | aPackage.getOpaqueBehaviors()->sortedBy(name))]
	[aBehavior.name.toUpperFirst()/]Execution.cpp
[/for]
[for (aCOA : CallOperationAction | aPackage.getCallOperationActions()->sortedBy(name))]
[if (not aCOA.hasCOAAMethod())][aCOA.name.toUpperFirst()/]Execution.cpp[/if]
[/for]
[for (aClassifier : Classifier | getClassiferExecutions()->sortedBy(name))]
	[aClassifier.name.toUpperFirst()/]Execution.cpp
[/for]
[for (act : Activity | aPackage.allOwnedElements()->filter(Class).allOwnedElements()->filter(Operation).method->filter(Activity)->sortedBy(name))]
	[act.name.toUpperFirst()/]Execution.cpp
[/for]
[if (buildLibrary)]
	[packageName.concat('ExecPlugin.cpp')/]
	['impl/'.concat(packageName).concat('ExecPluginImpl.cpp')/]
[else]
	main.cpp
[/if]
)

INCLUDE_DIRECTORIES(
    .
	${MDE4CPP_HOME}/application/include
	${MDE4CPP_HOME}/application/include/abstractDataTypes
	${MDE4CPP_HOME}/application/include/PluginFramework
	${MDE4CPP_HOME}/application/include/util
	${MDE4CPP_HOME}/application/include/ecore
	${MDE4CPP_HOME}/application/include/fuml
	${MDE4CPP_HOME}/application/include/PrimitivetypesReflection
	${MDE4CPP_HOME}/application/include/uml
	${MDE4CPP_HOME}/application/include/[packageName/]
[if (not aPackage.includeEcorePackages())]
[for (pack : Package | aPackage.metaModelIncludesWithoutReflection()->sortedBy(name)) separator (',')]
	${MDE4CPP_HOME}/application/include/[pack.name/]
[/for]
[/if]
)

FIND_LIBRARY(PLUGINFRAMEWORK_DEBUG PluginFrameworkd ${MDE4CPP_HOME}/application/lib)
FIND_LIBRARY(PLUGINFRAMEWORK_RELEASE PluginFramework ${MDE4CPP_HOME}/application/lib)

[for (packName : String | aPackage.metaModelLibrariesNames())]
FIND_LIBRARY([packName.toUpperCase()/]_DEBUG [packName/]d ${MDE4CPP_HOME}/application/lib)
FIND_LIBRARY([packName.toUpperCase()/]_RELEASE [packName/] ${MDE4CPP_HOME}/application/lib)
[/for]

[if (buildLibrary)]
ADD_LIBRARY(${PROJECT_NAME} SHARED ${SOURCE_FILES})
SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES PREFIX "")
[else]
ADD_EXECUTABLE(${PROJECT_NAME} ${SOURCE_FILES})
SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES DEBUG_POSTFIX ${CMAKE_DEBUG_POSTFIX})
[/if]
TARGET_LINK_LIBRARIES(${PROJECT_NAME} 
	debug ${PLUGINFRAMEWORK_DEBUG}
[for (packName : String | aPackage.metaModelLibrariesNames())]
	debug ${[packName.toUpperCase()/]_DEBUG}
[/for]
)
TARGET_LINK_LIBRARIES(${PROJECT_NAME}
	optimized ${PLUGINFRAMEWORK_RELEASE}
[for (packName : String | aPackage.metaModelLibrariesNames())]
	optimized ${[packName.toUpperCase()/]_RELEASE}
[/for]
)

#-----------------------------------------------------
# DELIVERING binaries and header to ${MDE4CPP_HOME}
#-----------------------------------------------------

INSTALL(TARGETS ${PROJECT_NAME}
	RUNTIME DESTINATION ${MDE4CPP_HOME}/application/bin
[if (buildLibrary)]
    ARCHIVE DESTINATION ${MDE4CPP_HOME}/application/lib
[/if]
)

[if (buildLibrary)]
INSTALL(DIRECTORY . DESTINATION ${MDE4CPP_HOME}/application/include/${PROJECT_NAME}
	FILES_MATCHING PATTERN "*.hpp"
	PATTERN ".cmake" EXCLUDE
)
[/if]
[/file]

[file ('../build.gradle', false, 'UTF-8')]
apply plugin: 'base' 

description 'Build tasks for project: [packageName/]'

task build[packageName/](dependsOn: ['['/]'generate[packageName/]', 'compile[packageName/]All'[']'/]) {
	group '[packageName/]'
	description 'build [packageName/] in debug and release'
}
task build[packageName/]Debug(dependsOn: ['['/]'generate[packageName/]', 'compile[packageName/]AllDebug'[']'/]) {
	group '[packageName/]'
	description 'build [packageName/] in debug'
}
task build[packageName/]Release(dependsOn: ['['/]'generate[packageName/]', 'compile[packageName/]AllRelease'[']'/]) {
	group '[packageName/]'
	description 'build [packageName/] in release'
}

task compile[packageName/]All(dependsOn: [ '[' /]'compile[packageName/]', 'compile[execPackageName/]'[ ']' /]) {
	group '[packageName/]'
	description 'compile the binaries for the fuml generated model [packageName/] in release and debug'
}
task compile[packageName/]AllDebug(dependsOn: [ '[' /]'compile[packageName/]Debug', 'compile[execPackageName/]Debug'[ ']' /]) {
	group '[packageName/]'
	description 'compile the binaries for the fuml generated model [packageName/] in release and debug'
}

task compile[packageName/]AllRelease(dependsOn: [ '[' /]'compile[packageName/]Release', 'compile[execPackageName/]Release'[ ']' /]) {
	group '[packageName/]'
	description 'compile the binaries for the fuml generated model [packageName/] in release and debug'
}

task compile[packageName.toUpperFirst()/](dependsOn: ['['/]'compile[packageName.toUpperFirst()/]Debug', 'compile[packageName.toUpperFirst()/]Release'[']'/]) {
	group '[packageName/]'
	description 'compile [packageName/] in debug and release'
}
[generateCompileTask(packageName, packageName, 'Debug')/]
[generateCompileTask(packageName, packageName, 'Release')/]

task compile[execPackageName.toUpperFirst()/](dependsOn: ['['/]'compile[execPackageName.toUpperFirst()/]Debug', 'compile[execPackageName.toUpperFirst()/]Release'[']'/]) {
	group '[packageName/]'
	description 'compile [packageName/] in debug and release'
}
[generateCompileTask(execPackageName, packageName, 'Debug')/]
[generateCompileTask(execPackageName, packageName, 'Release')/]

task generate[packageName/](type: JavaExec) {
	group '[packageName/]'
	description 'generate C++ code of [packageName/].uml model'
	main = "-jar"
	workingDir "./model"
	args System.getenv('MDE4CPP_HOME') + "/application/generator/fUML4CPP.jar", "[packageName/].uml", "../src_gen"
	inputs.files file(System.getenv('MDE4CPP_HOME') + "/application/generator/fUML4CPP.jar"), file("model/[packageName/].uml")
	outputs.dir file("src_gen")
	
	doFirst {
		if (System.getenv('MDE4CPP_HOME') == null) {
			throw new GradleException('System environment variable "MDE4CPP_HOME" is not defined')
		}
		if (!file(System.getenv('MDE4CPP_HOME') + "/application/generator/fUML4CPP.jar").exists()) {
			throw new GradleException('fUML4CPP.jar is missing in folder ' + file(System.getenv('MDE4CPP_HOME') + '/application/generator') + '. Please run task createFUML4CPP!')
		}
	}
}

compile[packageName/]Debug.mustRunAfter generate[packageName/]
compile[packageName/]Release.mustRunAfter generate[packageName/]
compile[execPackageName/]Debug.mustRunAfter compile[packageName/]Debug
compile[execPackageName/]Release.mustRunAfter compile[packageName/]Release

clean.doFirst {
	def cmakeFolder = file('./src_gen/[packageName/]/.cmake/')
	if(cmakeFolder.exists()) {
    	delete cmakeFolder.absolutePath
   		println "deleting folder " + cmakeFolder.absolutePath
	}

	def cmakeFolderExec = file('./src_gen/[execPackageName/]/.cmake/')
	if(cmakeFolderExec.exists()) {
    	delete cmakeFolderExec.absolutePath
   		println "deleting folder " + cmakeFolderExec.absolutePath
	}
}
[/file]
[/template]

[template private generateCompileTask(packageName : String, groupName : String, buildType : String)]
task compile[packageName.toUpperFirst()/][buildType/] {
	group '[groupName/]'
	description 'compile [packageName/] in [buildType/]'

	def folder = new File(file('./src_gen/[packageName/]/.cmake/[buildType/]').absolutePath)
	if( !folder.exists() ) {
		folder.mkdirs()
	}

	doLast {
		exec {
			workingDir 'src_gen/[packageName/]/.cmake/[buildType/]'
			commandLine 'cmd', '/c', 'cmake -G "MinGW Makefiles" -D CMAKE_BUILD_TYPE=[buildType/] ' + file("./src_gen/[packageName/]").absolutePath
		}
		exec {
			workingDir 'src_gen/[packageName/]/.cmake/[buildType/]'
			if (make_parallel_jobs)
			{			
				commandLine 'cmd', '/c', 'mingw32-make install -j' + make_parallel_jobs
			}
			else
			{
				commandLine 'cmd', '/c', 'mingw32-make install' 
			}
		}
	}
}
[/template]