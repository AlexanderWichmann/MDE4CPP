[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateExecutionPluginImplementationSource('http://www.eclipse.org/uml2/5.0.0/UML')]

[import UML4CPP::generator::main::generateType /]
[import UML4CPP::generator::main::helper /]
[import fUML4CPP::generator::main::generateMainExecution /]
[import fUML4CPP::generator::main::parameterHelper /]

[template public generateExecutionPluginImplSource(aPackage : Package) { packageName : String = aPackage.name.toUpperFirst().concat('ExecPluginImpl'); }]
[file (aPackage.getPackageName().concat('Exec/impl/').concat(packageName).concat('.cpp'), false, 'UTF-8')]
#include "[packageName/].hpp"
[generateMainIncludes()/]
[if (not aPackage.allOwnedElements()->filter(Activity)->isEmpty())]
[let act : Activity = aPackage.allOwnedElements()->filter(Activity)->asOrderedSet()->first() ]
[generateActivityRelatedIncludes(act, aPackage)/]
[/let][/if]

using namespace [aPackage.name/];

//*********************************
// Constructor / Destructor
//*********************************
[packageName/]::[packageName/]()
{
}

[packageName/]::~[packageName/]()
{
}

std::string [packageName/]::eNAME()
{
	return "[aPackage.name/]Exec";
}

std::string [packageName/]::eNS_URI()
{
	return "[aPackage.URI/]";
}

std::string [packageName/]::eNS_PREFIX()
{
	return "[if(not (aPackage.namespace.oclIsUndefined()))][aPackage.namespace.name/][/if]";
}


boost::any [packageName/]::executeActivity(std::string activityName, std::shared_ptr<std::vector<boost::any>> parameterList)
{
	[generateLocusInitialization()/]

[if (not aPackage.allOwnedElements()->filter(Activity)->isEmpty())]
[let act : Activity = aPackage.allOwnedElements()->filter(Activity)->asOrderedSet()->first()]
	[act.generateParameterFromAny(aPackage)/]
	[act.generateStartActivityExecution(aPackage)/]   
	[act.generateReturnParameter(aPackage)/]
[/let][else]
	return nullptr;
[/if]
}

[/file]
[/template]

[query public listNumber(aParameter : Parameter, anActivity : Activity) : Integer =  anActivity.ownedParameter->select((direction = ParameterDirectionKind::inout) or (direction = ParameterDirectionKind::_in))->indexOf(aParameter)-1 /]

[template public generateParameterFromAny(anActivity : Activity, aPackage : Package)]
[for (par : Parameter | anActivity.ownedParameter->select((direction = ParameterDirectionKind::inout) or (direction = ParameterDirectionKind::_in)))]
[if(par.supportedTypes())]
[par.type.generateCppType()/] [par.name.toLowerFirst()/] = [par.default/];
[else]
std::shared_ptr<[par.type.generateCppType(true)/]> [par.name.toLowerFirst()/] = boost::any_cast<std::shared_ptr<[par.type.generateCppType(true)/]>>(parameterList->at([par.listNumber(anActivity)/]));
[/if]

[/for]
[/template]

[template public generateReturnParameter(anActivity : Activity, aPackage : Package)]
[if (anActivity.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->notEmpty())]
//The activity has a return parameter
assert(resultPList->front());
[let par : Parameter = anActivity.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->first()]
[if(par.supportedTypes())]
std::shared_ptr<fUML::[par.type.name/]Value> ret = std::dynamic_pointer_cast<fUML::[par.type.name/]Value>(resultPList->front()->getValues()->front());
assert(ret != nullptr);
return ret->getValue();
[else]
std::shared_ptr<fUML::Reference> [par.name/]Value = std::dynamic_pointer_cast<fUML::Reference>(resultPList->front()->getValues()->front());
std::shared_ptr<[par.type.name.toUpperFirst()/]Execution> [par.name/]UmlLinker = std::dynamic_pointer_cast<[par.type.name.toUpperFirst()/]Execution>([par.name/]Value->getReferent());
return [par.name/]UmlLinker->getUmlValue();
[/if]
[/let]
[else]
std::cout << "Activity [anActivity.myQualifiedName()/] has no return parameter" << std::endl;
return nullptr;
[/if]
[/template]
