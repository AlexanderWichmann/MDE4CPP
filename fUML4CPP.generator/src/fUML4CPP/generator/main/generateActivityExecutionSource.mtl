[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateActivityExecutionSource('http://www.eclipse.org/uml2/5.0.0/UML')]
 
[import fUML4CPP::generator::main::generateOpaqueBehaviorExecution /]
[import fUML4CPP::generator::main::parameterHelper /]
[import UML4CPP::generator::main::generateType /]
[import UML4CPP::generator::main::helper /]

[template public generateActivityExecutionSource(aActivity : Activity)
{aPackage:Package = aActivity.ancestors()->filter(Package)->first(); 
className : String = aActivity.name.toUpperFirst().concat('Execution');
}]
[file (aPackage.getPackageName().concat('Exec/').concat(className).concat('.cpp'), false, 'UTF-8')]
#include "[aPackage.getPackageName()/]Exec/[className/].hpp"

[defineDebugMacro()/]

#include <cassert>
#include <iostream>
#include <memory>
#include <vector>

#include "abstractDataTypes/SubsetUnion.hpp"
#include "fUML/ActivityParameterNodeActivation.hpp"
#include "fUML/ActivityNodeActivationGroup.hpp"
#include "fUML/DispatchStrategy.hpp"
#include "fUML/Executor.hpp"
#include "fUML/ExecutionFactoryL3.hpp"
#include "fUML/FirstChoiceStrategy.hpp"
#include "fUML/FUMLFactory.hpp"
#include "fUML/Locus.hpp"
#include "fUML/ParameterValue.hpp"
#include "fUML/ObjectToken.hpp"
#include "fUML/Token.hpp"
#include "fUML/Value.hpp"
#include "uml/Activity.hpp"
#include "uml/Classifier.hpp"
#include "uml/FunctionBehavior.hpp"

[for ( par : Parameter | aActivity.ownedParameter->asOrderedSet())]
[par.generateParameterInclude(aPackage)/]
[/for]

[if (aActivity.ownedParameter->asSet()->parametersArePointers())]
#include "fUML/Reference.hpp"
#include "[aPackage.getPackageName()/]/[aPackage.getPackageName()/]Factory.hpp"
[/if]

//include Model package
[for (pack : Package | aPackage->asOrderedSet()->sortedBy(name))]
#include "[pack.getPackageName()/]/[pack.getPackageName().toUpperFirst().concat('Package')/].hpp"
[/for]

[aPackage.getOpaqueBehaviors()->sortedBy(myQualifiedName()).generateInclude()/]

using namespace [aPackage.name/];

[className/]::[className/]()
{
}

[className/]::~[className/]()
{
}

[className/]::[className/](const [className/] &obj):
	ActivityExecutionImpl(obj)
{
}

void [className/]::terminate()
{
    this->getActivationGroup()->terminateAll();
}

std::shared_ptr<ecore::EObject> [className/]::copy() const
{
	std::shared_ptr<ecore::EObject> element(new [className/](*this));
	return element;
}

void [className/]::execute()
{
	// Execute the activity for this execution by creating an activity node activation group and activating all the activity nodes in the activity.
	// When this is complete, copy the values on the tokens offered by output parameter nodes to the corresponding output parameters.
	std::shared_ptr<uml::Activity> activity = std::dynamic_pointer_cast<uml::Activity>(this->getTypes()->front());
	assert(activity != nullptr);

	DEBUG_MESSAGE(std::cout << "[ '[' /]execute[ ']' /] Activity " << activity->getName() << "..." << std::endl;)
	
	if(this->getContext() != nullptr){
		DEBUG_MESSAGE(std::cout << "[ '[' /]execute[ ']' /] context = " << this->getContext()->objectId() << std::endl;)
	}

	this->setActivationGroup(std::shared_ptr<fUML::ActivityNodeActivationGroup>(fUML::FUMLFactory::eInstance()->createActivityNodeActivationGroup()));
	struct null_deleter{void operator()(void const *) const { } };
	this->getActivationGroup()->setActivityExecution(std::shared_ptr<[className/]>(this, null_deleter()));
	this->getActivationGroup()->activate(activity->getNode(), activity->getEdge());

	DEBUG_MESSAGE(std::cout << "[ '[' /]execute[ ']' /] Getting output parameter node activations..." << std::endl;)

	std::shared_ptr<Bag<fUML::ActivityParameterNodeActivation> > outputActivations =
	this->getActivationGroup()->getOutputParameterNodeActivations();

    assert(outputActivations != nullptr);

	DEBUG_MESSAGE(std::cout << "[ '[' /]execute[ ']' /] There are " << outputActivations->size() << " output parameter node activations." << std::endl;)
	
    for (unsigned int i = 0; i < outputActivations->size(); i++) 
	{
 		std::shared_ptr<fUML::ActivityParameterNodeActivation> outputActivation = outputActivations->at(i);
 		std::shared_ptr<fUML::ParameterValue> parameterValue(fUML::FUMLFactory::eInstance()->createParameterValue());
 		parameterValue->setParameter((std::dynamic_pointer_cast<uml::ActivityParameterNode>(outputActivation->getNode()))->getParameter());
 		std::shared_ptr<Bag<fUML::Token> > tokens = outputActivation->getTokens();
 		for (unsigned int j = 0; j < tokens->size(); j++) 
		{
            std::shared_ptr<fUML::Token> token = tokens->at(j);
            std::shared_ptr<fUML::Value> value = std::dynamic_pointer_cast<fUML::ObjectToken>(token)->getValue();
 			if (nullptr != value) 
			{
                parameterValue->getValues()->push_back(value);
 			}
 		}
	 	this->setParameterValue(parameterValue);
	}

	DEBUG_MESSAGE(std::cout << "[ '[' /]execute[ ']' /] Activity " << activity->getName() << " completed." << std::endl;)
}
[/file]
[/template]
