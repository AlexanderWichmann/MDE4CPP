/*-------------------------------------------------
*
* Tasks created by ecore4CPP Generator 
*
*-------------------------------------------------
*/

apply plugin: 'cpp'

description 'C++ project of model ecore.ecore, generated by Ecore4CPP'

File appendDebugSuffix(File binaryFile) {
	int extensionSeparatorIndex = binaryFile.path.lastIndexOf('.')
	return new File(binaryFile.path.substring(0, extensionSeparatorIndex) + "d" + binaryFile.path.substring(extensionSeparatorIndex))
}

task deliverEcore(dependsOn: ['deliverEcoreHeaders','deliverEcoreDebugSharedLibrary', 'deliverEcoreReleaseSharedLibrary']) {
	description 'deliver ecore header, debug and release libraries to application folder (%MDE4CPP_HOME%/application)'
}

task deliverEcoreHeaders(type: Copy) {
	description 'deliver ecore header to %MDE4CPP_HOME%/application/include/ecore'
	from "."
	into System.getenv('MDE4CPP_HOME')+"/application/include/ecore"
	include "**/*.hpp"
	exclude "build", ".gradle"
}

task deliverEcoreDebugSharedLibrary(type: Copy) {
	description 'deliver ecore debug libary to %MDE4CPP_HOME%/application/bin'
	from "build/libs/ecore/shared/debug"
	into System.getenv('MDE4CPP_HOME')+"/application/bin"
	include "ecored.dll"
}

task deliverEcoreReleaseSharedLibrary(type: Copy) {
	description 'deliver ecore release libary to %MDE4CPP_HOME%/application/bin'
	from "build/libs/ecore/shared/release"
	into System.getenv('MDE4CPP_HOME')+"/application/bin"
	include "ecore.dll"
}

model {
    toolChains {
    	 gcc(Gcc) {
    	 	"g++"
    	 }
    }
	
    buildTypes {
        debug 
        release
    }

    components {
        ecore(NativeLibrarySpec)
        {
        	sources {
                cpp {
                    source {
                        srcDirs "." 
						include "impl/EAnnotationImpl.cpp"
						include "impl/EAttributeImpl.cpp"
						include "impl/EClassImpl.cpp"
						include "impl/EClassifierImpl.cpp"
						include "impl/EDataTypeImpl.cpp"
						include "impl/EEnumImpl.cpp"
						include "impl/EEnumLiteralImpl.cpp"
						include "impl/EFactoryImpl.cpp"
						include "impl/EGenericTypeImpl.cpp"
						include "impl/EModelElementImpl.cpp"
						include "impl/ENamedElementImpl.cpp"
						include "impl/EObjectImpl.cpp"
						include "impl/EOperationImpl.cpp"
						include "impl/EPackageImpl.cpp"
						include "impl/EParameterImpl.cpp"
						include "impl/EReferenceImpl.cpp"
						include "impl/EStringToStringMapEntryImpl.cpp"
						include "impl/EStructuralFeatureImpl.cpp"
						include "impl/ETypeParameterImpl.cpp"
						include "impl/ETypedElementImpl.cpp"
						include	"impl/EcoreFactoryImpl.cpp"
						include	"EcoreFactory.cpp"
						include	"impl/EcorePackageImpl.cpp"
						include	"EcorePackage.cpp"
                    }
					exportedHeaders {
                        srcDirs ".", "../", System.getenv('MDE4CPP_HOME')+"/application/include"
                        include "**/*.hpp"
                    }
                }
            }

			binaries.withType(StaticLibraryBinarySpec) {
				buildable = false
			}
        }
		
		withType(NativeComponentSpec) {
			binaries.withType(NativeBinarySpec) {
				if(buildType == buildTypes.debug) {
					if (it instanceof SharedLibraryBinarySpec) {
						sharedLibraryFile = appendDebugSuffix(sharedLibraryFile)
						sharedLibraryLinkFile = appendDebugSuffix(sharedLibraryLinkFile)
					} else if (it instanceof StaticLibraryBinarySpec) {
						staticLibraryFile = appendDebugSuffix(staticLibraryFile)
					} else {
						throw new GradleException("Unknown native library binary")
					}
				}
			}
        }
    }
    
    binaries {
        all {
        	cppCompiler.args '-std=c++11','-Wall', '-Wno-overloaded-virtual', '-pipe'
			if (buildType == buildTypes.debug) {
				cppCompiler.args '-g'
			}
			else {
				cppCompiler.args '-O3', '-DNDEBUG'
			}
        }
    }
}

build.finalizedBy(deliverEcore)
