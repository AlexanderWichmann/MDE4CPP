//********************************************************************
//*    
//* Warning: This file was generated by ecore4CPP Generator
//*
//********************************************************************

#ifndef UML_OBJECTNODE_HPP
#define UML_OBJECTNODE_HPP

#ifdef NDEBUG
    #define DEBUG_MESSAGE(a) /**/
#else
    #define DEBUG_MESSAGE(a) a
#endif

#include <string>
#include <map>
#include <vector>
#include "boost/any.hpp"

//*********************************
// generated Includes

//Forward Declaration for used types
namespace uml 
{
	class Activity;
}

namespace uml 
{
	class ActivityEdge;
}

namespace uml 
{
	class ActivityGroup;
}

namespace uml 
{
	class ActivityNode;
}

namespace uml 
{
	class ActivityPartition;
}

namespace uml 
{
	class Behavior;
}

namespace uml 
{
	class Classifier;
}

namespace uml 
{
	class Comment;
}

namespace uml 
{
	class Dependency;
}

namespace ecore 
{
	class EAnnotation;
}

namespace uml 
{
	class Element;
}

namespace uml 
{
	class InterruptibleActivityRegion;
}

namespace uml 
{
	class Namespace;
}

namespace uml 
{
	class RedefinableElement;
}

namespace uml 
{
	class State;
}

namespace uml 
{
	class StringExpression;
}

namespace uml 
{
	class StructuredActivityNode;
}

namespace uml 
{
	class Type;
}

namespace uml 
{
	class TypedElement;
}

namespace uml 
{
	class ValueSpecification;
}

// base class includes
#include "ActivityNode.hpp"

#include "TypedElement.hpp"

// enum includes
#include "ObjectNodeOrderingKind.hpp"

#include "VisibilityKind.hpp"


//*********************************
namespace uml 
{
	/*!
	 An ObjectNode is an abstract ActivityNode that may hold tokens within the object flow in an Activity. ObjectNodes also support token selection, limitation on the number of tokens held, specification of the state required for tokens being held, and carrying control values.
	<p>From package UML::Activities.</p> */
	class ObjectNode:virtual public ActivityNode,virtual public TypedElement	{
		public:
 			ObjectNode(const ObjectNode &) {}
			ObjectNode& operator=(ObjectNode const&) = delete;
	
		protected:
			ObjectNode(){}

		public:
			virtual ecore::EObject* copy() const = 0;

			//destructor
			virtual ~ObjectNode() {}

			//*********************************
			// Operations
			//*********************************
			/*!
			 A selection Behavior has one input Parameter and one output Parameter. The input Parameter must have the same type as  or a supertype of the type of ObjectNode, be non-unique, and have multiplicity 0..*. The output Parameter must be the same or a subtype of the type of ObjectNode. The Behavior cannot have side effects.
			selection<>null implies
				selection.inputParameters()->size()=1 and
				selection.inputParameters()->forAll(p | not p.isUnique and p.is(0,*) and self.type.conformsTo(p.type)) and
				selection.outputParameters()->size()=1 and
					selection.inputParameters()->forAll(p | self.type.conformsTo(p.type)) */ 
			virtual bool input_output_parameter(boost::any diagnostics,std::map <   boost::any, boost::any > * context)  = 0;
			
			/*!
			 If an ObjectNode has a selection Behavior, then the ordering of the object node is ordered, and vice versa.
			(selection<>null) = (ordering=ObjectNodeOrderingKind::ordered) */ 
			virtual bool selection_behavior(boost::any diagnostics,std::map <   boost::any, boost::any > * context)  = 0;
			
			/*!
			 If isControlType=false, the ActivityEdges incoming to or outgoing from an ObjectNode must all be ObjectFlows.
			(not isControlType) implies incoming->union(outgoing)->forAll(oclIsKindOf(ObjectFlow)) */ 
			virtual bool object_flow_edges(boost::any diagnostics,std::map <   boost::any, boost::any > * context)  = 0;
			
			
			//*********************************
			// Attributes Getter Setter
			//*********************************
			/*!
			 Indicates whether the type of the ObjectNode is to be treated as representing control values that may traverse ControlFlows.
			<p>From package UML::Activities.</p> */ 
			virtual bool getIsControlType() const = 0;
			
			/*!
			 Indicates whether the type of the ObjectNode is to be treated as representing control values that may traverse ControlFlows.
			<p>From package UML::Activities.</p> */ 
			virtual void setIsControlType (bool _isControlType)= 0; 
			
			/*!
			 Indicates how the tokens held by the ObjectNode are ordered for selection to traverse ActivityEdges outgoing from the ObjectNode.
			<p>From package UML::Activities.</p> */ 
			virtual ObjectNodeOrderingKind getOrdering() const = 0;
			
			/*!
			 Indicates how the tokens held by the ObjectNode are ordered for selection to traverse ActivityEdges outgoing from the ObjectNode.
			<p>From package UML::Activities.</p> */ 
			virtual void setOrdering (ObjectNodeOrderingKind _ordering)= 0; 
			
			
			//*********************************
			// Reference
			//*********************************
			/*!
			 The States required to be associated with the values held by tokens on this ObjectNode.
			<p>From package UML::Activities.</p> */
			virtual std::vector<uml::State * > *  getInState() const = 0;
			
			/*!
			 A Behavior used to select tokens to be offered on outgoing ActivityEdges.
			<p>From package UML::Activities.</p> */
			virtual uml::Behavior *  getSelection() const = 0;
			
			/*!
			 A Behavior used to select tokens to be offered on outgoing ActivityEdges.
			<p>From package UML::Activities.</p> */
			virtual void setSelection(uml::Behavior *  _selection) = 0;
			
			/*!
			 The maximum number of tokens that may be held by this ObjectNode. Tokens cannot flow into the ObjectNode if the upperBound is reached. If no upperBound is specified, then there is no limit on how many tokens the ObjectNode can hold.
			<p>From package UML::Activities.</p> */
			virtual uml::ValueSpecification *  getUpperBound() const = 0;
			
			/*!
			 The maximum number of tokens that may be held by this ObjectNode. Tokens cannot flow into the ObjectNode if the upperBound is reached. If no upperBound is specified, then there is no limit on how many tokens the ObjectNode can hold.
			<p>From package UML::Activities.</p> */
			virtual void setUpperBound(uml::ValueSpecification *  _upperBound) = 0;
			
			

		protected:
			//*********************************
			// Attribute Members
			//*********************************
			/*!
			 Indicates whether the type of the ObjectNode is to be treated as representing control values that may traverse ControlFlows.
			<p>From package UML::Activities.</p> */ 
			bool m_isControlType =  false;
			/*!
			 Indicates how the tokens held by the ObjectNode are ordered for selection to traverse ActivityEdges outgoing from the ObjectNode.
			<p>From package UML::Activities.</p> */ 
			ObjectNodeOrderingKind m_ordering = ObjectNodeOrderingKind::FIFO ;
			
			
			//*********************************
			// Reference Members
			//*********************************
			/*!
			 The States required to be associated with the values held by tokens on this ObjectNode.
			<p>From package UML::Activities.</p> */
			std::vector<uml::State * > *  m_inState =  nullptr ;
			/*!
			 A Behavior used to select tokens to be offered on outgoing ActivityEdges.
			<p>From package UML::Activities.</p> */
			uml::Behavior *  m_selection =  nullptr ;
			/*!
			 The maximum number of tokens that may be held by this ObjectNode. Tokens cannot flow into the ObjectNode if the upperBound is reached. If no upperBound is specified, then there is no limit on how many tokens the ObjectNode can hold.
			<p>From package UML::Activities.</p> */
			uml::ValueSpecification *  m_upperBound =  nullptr ;
			

		public:
			//*********************************
			// Union Getter
			//*********************************
			/*!
			 The Elements owned by this Element.
			<p>From package UML::CommonStructure.</p> */
			virtual std::vector<uml::Element * > *  getOwnedElement() const = 0;/*!
			 ActivityGroups containing the ActivityNode.
			<p>From package UML::Activities.</p> */
			virtual std::vector<uml::ActivityGroup * > *  getInGroup() const = 0;/*!
			 The Element that owns this Element.
			<p>From package UML::CommonStructure.</p> */
			virtual uml::Element *  getOwner() const = 0;/*!
			 The RedefinableElement that is being redefined by this element.
			<p>From package UML::Classification.</p> */
			virtual std::vector<uml::RedefinableElement * > *  getRedefinedElement() const = 0; 
	};

}
#endif /* end of include guard: UML_OBJECTNODE_HPP */

