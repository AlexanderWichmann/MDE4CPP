//********************************************************************
//*    
//* Warning: This file was generated by ecore4CPP Generator
//*
//********************************************************************

#ifndef UML_NAMESPACENAMESPACEIMPL_HPP
#define UML_NAMESPACENAMESPACEIMPL_HPP

#ifdef NDEBUG
    #define DEBUG_MESSAGE(a) /**/
#else
    #define DEBUG_MESSAGE(a) a
#endif

//*********************************
// generated Includes

//Model includes
#include "../Namespace.hpp"

#include "impl/NamedElementImpl.hpp"

#include "SubsetUnion.hpp"



//*********************************
namespace uml 
{
	class NamespaceImpl :virtual public NamedElementImpl, virtual public Namespace 
	{
		public: 
			NamespaceImpl(const NamespaceImpl & obj);
			virtual ecore::EObject *  copy() const;

		private:    
			NamespaceImpl& operator=(NamespaceImpl const&) = delete;

		protected:
			friend class UmlFactoryImpl;
			NamespaceImpl();

		public:
			//destructor
			virtual ~NamespaceImpl();
			
			//*********************************
			// Operations
			//*********************************
			/*!
			 All the members of a Namespace are distinguishable within it.
			membersAreDistinguishable() */ 
			virtual bool
			 members_distinguishable(boost::any diagnostics,std::map <   boost::any, boost::any >  context)  ;
			
			/*!
			 A Namespace cannot have a PackageImport to itself.
			packageImport.importedPackage.oclAsType(Namespace)->excludes(self) */ 
			virtual bool
			 cannot_import_self(boost::any diagnostics,std::map <   boost::any, boost::any >  context)  ;
			
			/*!
			 A Namespace cannot have an ElementImport to one of its ownedMembers.
			elementImport.importedElement.oclAsType(Element)->excludesAll(ownedMember) */ 
			virtual bool
			 cannot_import_ownedMembers(boost::any diagnostics,std::map <   boost::any, boost::any >  context)  ;
			
			/*!
			 Creates an import of the specified element into this namespace with the specified visibility. */ 
			virtual std::shared_ptr<uml::ElementImport> 
			 createElementImport(std::shared_ptr<uml::PackageableElement>  element,VisibilityKind visibility)  ;
			
			/*!
			 Creates an import of the specified package into this namespace with the specified visibility. */ 
			virtual std::shared_ptr<uml::PackageImport> 
			 createPackageImport(std::shared_ptr<uml::Package>  package_,VisibilityKind visibility)  ;
			
			/*!
			 Retrieves the elements imported by this namespace. */ 
			virtual std::shared_ptr<Bag<uml::PackageableElement> >
			 getImportedElements()  ;
			
			/*!
			 Retrieves the packages imported by this namespace. */ 
			virtual std::shared_ptr<Bag<uml::Package> >
			 getImportedPackages()  ;
			
			/*!
			 */ 
			virtual std::shared_ptr<Bag<uml::NamedElement> >
			 getOwnedMembers()  ;
			
			/*!
			 The query excludeCollisions() excludes from a set of PackageableElements any that would not be distinguishable from each other in this Namespace.
			result = (imps->reject(imp1  | imps->exists(imp2 | not imp1.isDistinguishableFrom(imp2, self))))
			<p>From package UML::CommonStructure.</p> */ 
			virtual std::shared_ptr<Bag<uml::PackageableElement> >
			 excludeCollisions(std::shared_ptr<Bag<uml::PackageableElement> >  imps)  ;
			
			/*!
			 The query getNamesOfMember() gives a set of all of the names that a member would have in a Namespace, taking importing into account. In general a member can have multiple names in a Namespace if it is imported more than once with different aliases.
			result = (if self.ownedMember ->includes(element)
			then Set{element.name}
			else let elementImports : Set(ElementImport) = self.elementImport->select(ei | ei.importedElement = element) in
			  if elementImports->notEmpty()
			  then
			     elementImports->collect(el | el.getName())->asSet()
			  else 
			     self.packageImport->select(pi | pi.importedPackage.visibleMembers().oclAsType(NamedElement)->includes(element))-> collect(pi | pi.importedPackage.getNamesOfMember(element))->asSet()
			  endif
			endif)
			<p>From package UML::CommonStructure.</p> */ 
			virtual std::shared_ptr<Bag<std::string> >
			 getNamesOfMember(std::shared_ptr<uml::NamedElement>  element)  ;
			
			/*!
			 The query importMembers() defines which of a set of PackageableElements are actually imported into the Namespace. This excludes hidden ones, i.e., those which have names that conflict with names of ownedMembers, and it also excludes PackageableElements that would have the indistinguishable names when imported.
			result = (self.excludeCollisions(imps)->select(imp | self.ownedMember->forAll(mem | imp.isDistinguishableFrom(mem, self))))
			<p>From package UML::CommonStructure.</p> */ 
			virtual std::shared_ptr<Bag<uml::PackageableElement> >
			 importMembers(std::shared_ptr<Bag<uml::PackageableElement> >  imps)  ;
			
			/*!
			 The importedMember property is derived as the PackageableElements that are members of this Namespace as a result of either PackageImports or ElementImports.
			result = (self.importMembers(elementImport.importedElement->asSet()->union(packageImport.importedPackage->collect(p | p.visibleMembers()))->asSet()))
			<p>From package UML::CommonStructure.</p> */ 
			virtual std::shared_ptr<Bag<uml::PackageableElement> >
			 getImportedMembers()  ;
			
			/*!
			 The Boolean query membersAreDistinguishable() determines whether all of the Namespace's members are distinguishable within it.
			result = (member->forAll( memb |
			   member->excluding(memb)->forAll(other |
			       memb.isDistinguishableFrom(other, self))))
			<p>From package UML::CommonStructure.</p> */ 
			virtual bool
			 membersAreDistinguishable()  ;
			
			
			
			//*********************************
			// Attributes Getter Setter
			//*********************************
			
			
			//*********************************
			// Reference
			//*********************************
			/*!
			 Specifies a set of Constraints owned by this Namespace.
			<p>From package UML::CommonStructure.</p> */
			virtual 		std::shared_ptr<SubsetUnion<uml::Constraint, uml::NamedElement > >
			 getOwnedRule() const ;
			
			/*!
			 References the ElementImports owned by the Namespace.
			<p>From package UML::CommonStructure.</p> */
			virtual 		std::shared_ptr<SubsetUnion<uml::ElementImport, uml::Element > >
			 getElementImport() const ;
			
			/*!
			 References the PackageImports owned by the Namespace.
			<p>From package UML::CommonStructure.</p> */
			virtual 		std::shared_ptr<SubsetUnion<uml::PackageImport, uml::Element > >
			 getPackageImport() const ;
			
			
			/*!
			 References the PackageableElements that are members of this Namespace as a result of either PackageImports or ElementImports.
			<p>From package UML::CommonStructure.</p> */
			virtual 		std::shared_ptr<Subset<uml::PackageableElement, uml::NamedElement > >
			 getImportedMember() const ;
			
			
							
			
			//*********************************
			// Union Getter
			//*********************************
			/*!
			 A collection of NamedElements owned by the Namespace.
			<p>From package UML::CommonStructure.</p> */
			virtual 		std::shared_ptr<SubsetUnion<uml::NamedElement, uml::Element
					,uml::NamedElement > >
			 getOwnedMember() const ;/*!
			 A collection of NamedElements identifiable within the Namespace, either by being owned or by being introduced by importing or inheritance.
			<p>From package UML::CommonStructure.</p> */
			virtual 		std::shared_ptr<Union<uml::NamedElement> > getMember() const ;/*!
			 The Elements owned by this Element.
			<p>From package UML::CommonStructure.</p> */
			virtual 		std::shared_ptr<Union<uml::Element> > getOwnedElement() const ;/*!
			 The Element that owns this Element.
			<p>From package UML::CommonStructure.</p> */
			virtual std::shared_ptr<uml::Element > getOwner() const ; 
			 
			//*********************************
			// Structural Feature Getter/Setter
			//*********************************
			
			virtual boost::any eGet(int featureID, bool resolve, bool coreType) const ;
			
		protected:
			virtual std::shared_ptr<ecore::EClass> eStaticClass() const;
	};
}
#endif /* end of include guard: UML_NAMESPACENAMESPACEIMPL_HPP */

